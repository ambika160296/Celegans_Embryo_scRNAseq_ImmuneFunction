---
title: "embryo_intestine_scRNAseq"
author: "Jessica Hill"
date: "9/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---

# Install packages
```{r}
#install.packages('Seurat')
#packageVersion('Seurat')
#remotes::install_github('satijalab/seurat-wrappers')

#reticulate::py_install(packages = 'umap-learn', envname = 'r-reticulate')
#BiocManager::install("limma")
#install.packages("hdf5r")
#BiocManager::install("biomaRt")
#install.packages("clustree")
```

# Load packages
```{r echo=FALSE}
library(biomaRt)
library(Seurat)
library(tidyverse)
library(patchwork)
library(limma)
library(clustree)
```

---
# Get started!

```{r}
emb.GFPpooled.data <- Read10X_h5("./10x_cloud_analysis/GFP_pooled_count/raw_feature_bc_matrix.h5")
```

Get filternames from https://parasite.wormbase.org/biomart/martview
```{r}
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

genes.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "wbps_gene_id"),
      value = list("caelegprjna13758", rownames(emb.GFPpooled.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name')
      )

mitoList = genes.df[genes.df$chromosome_name == 'MtDNA', 'external_gene_id']
genes.df$chromosome_name = NULL

c(nrow(genes.df), nrow(emb.GFPpooled.data))

# there are genes missing
nrow(emb.GFPpooled.data)-nrow(genes.df)
```

There are `r nrow(emb.GFPpooled.data)-nrow(genes.df)` genes that are now dead, remove them from the input matrix.

```{r}
emb.GFPpooled.data.filt <- emb.GFPpooled.data[rownames(emb.GFPpooled.data) %in% genes.df$wbps_gene_id,]

# The two data structures do not have the same order of WBGeneIDs
identical(rownames(emb.GFPpooled.data.filt), genes.df$wbps_gene_id)

# Use match to make sure they are in the same order
identical(rownames(emb.GFPpooled.data.filt),
          genes.df[match(rownames(emb.GFPpooled.data.filt), genes.df$wbps_gene_id),]$wbps_gene_id
)

# now replace the WBGeneIDs with gene names
rownames(emb.GFPpooled.data.filt) <- genes.df[
  match(rownames(emb.GFPpooled.data.filt),
        genes.df$wbps_gene_id)
  ,]$external_gene_id

# are there NAs?
sum(!is.na(rownames(emb.GFPpooled.data.filt)))

head(emb.GFPpooled.data.filt)
```

```{r}
emb.GFPpooled <- CreateSeuratObject(counts = emb.GFPpooled.data.filt, project = "emb_GFPpooled", min.cells = 3, min.features = 200)
```

```{r}
length(unique(genes.df$wbps_gene_id))
length(unique(rownames(emb.GFPpooled)))
rownames(emb.GFPpooled)[!(rownames(emb.GFPpooled) %in% genes.df$wbps_gene_id)]
```

# Quality control metrics

- `nFeature_RNA` is the number of genes detected in each cell. 
- `nCount_RNA` is the total number of molecules detected within a cell (AKA total UMIs per cell)
- Low `nFeature_RNA` indicates that the cell may be dead or dying or an empty droplet
- High `nCount_RNA` and/or `nFeature_RNA` indicates that the "cell" may in fact be a doublet (or multiplet)


show QC metrics for the first 5 cells 
```{r}
head(emb.GFPpooled@meta.data, 5)
```

Mitochondrial genome percentage 
```{r}
mitoIndices = which(rownames(emb.GFPpooled) %in% mitoList)
emb.GFPpooled[["percent.mt"]] <- PercentageFeatureSet(emb.GFPpooled, features = mitoIndices)
```


Visualize QC metrics as a violin plot
```{r}
VlnPlot(emb.GFPpooled, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

ggsave("./Output/GFP_pooled/emb.GFPpooled.VlnPlot.png")
```

FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
```{r}
plot1 <- FeatureScatter(emb.GFPpooled, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.GFPpooled, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

ggsave("./Output/GFP_pooled/emb.GFPpooled.FeatureScatter.png")
```


# Filter based on features

cells being filtered due to mito percent: 
```{r}
sum(emb.GFPpooled$percent.mt > 50)/ length(emb.GFPpooled$percent.mt)

emb.GFPpooled <- subset(emb.GFPpooled, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```

# Visualize after filtering
```{r}
VlnPlot(emb.GFPpooled, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
ggsave("./Output/GFP_pooled/emb.GFPpooled.VlnPlot.filt.png")

FeatureScatter(emb.GFPpooled, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
ggsave("./Output/GFP_pooled/emb.GFPpooled.FeatureScatter.filt.png")
```


# Normalize the data

Normalize the count data present in the assay. 

LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. This is then natural-log transformed using log1p.

Scale.factor: Sets the scale factor for cell-level normalization

```{r}
emb.GFPpooled <- NormalizeData(emb.GFPpooled, normalization.method = "LogNormalize", scale.factor = 10000)
```

# Feature selection

Identify highly variable features to focus on in downstream analysis
```{r}
emb.GFPpooled <- FindVariableFeatures(emb.GFPpooled, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(emb.GFPpooled), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(emb.GFPpooled)
LabelPoints(plot = plot1, points = top10, repel = TRUE)
ggsave("./Output/GFP_pooled/emb.GFPpooled.VarFeatures.png")
```


# Normalization

Scale the data so that each gene has a mean expression of 0 and variance of 1 across all cells
```{r}
all.genes <- rownames(emb.GFPpooled)
emb.GFPpooled <- ScaleData(emb.GFPpooled, features = all.genes)
```


# Linear dimensionality reduction 

PCA linear dimensionality reduction
```{r}
emb.GFPpooled <- RunPCA(emb.GFPpooled, features = VariableFeatures(object = emb.GFPpooled))
```

Examine and visualize PCA results a few different ways
```{r}
print(emb.GFPpooled[["pca"]], dims = 1:5, nfeatures = 5)
```

```{r}
# top genes associated with reduction components
VizDimLoadings(emb.GFPpooled, dims = 1:2, reduction = "pca")
ggsave("./Output/GFP_pooled/emb.GFPpooled.DimLoadings.png")
```

```{r}
DimPlot(emb.GFPpooled, reduction = "pca")
ggsave("./Output/GFP_pooled/emb.GFPpooled.DimPlot.png")
```

```{r}
DimHeatmap(emb.GFPpooled, dims = 1, cells = 500, balanced = TRUE)
ggsave("./Output/GFP_pooled/emb.GFPpooled.HeatMap1.png")
```

```{r}
DimHeatmap(emb.GFPpooled, dims = 1:6, cells = 500, balanced = TRUE)
ggsave("./Output/GFP_pooled/emb.GFPpooled.HeatMap1-6.png")
```

# Determine dataset dimensionality

How many components should we include? 
Use resampling test
```{r}
emb.GFPpooled <- JackStraw(emb.GFPpooled, num.replicate = 100)
emb.GFPpooled <- ScoreJackStraw(emb.GFPpooled, dims = 1:20)
```

The JackStrawPlot() function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). ‘Significant’ PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line). 

```{r}
JackStrawPlot(emb.GFPpooled, dims = 1:20)
ggsave("./Output/GFP_pooled/emb.GFPpooled.JackStrawPlot.png")
```


An alternative, more approximate technique is the elbow plot, which ranges principle components based on the percentage of variance explained by each PC.

```{r}
ElbowPlot(emb.GFPpooled)
ggsave("./Output/GFP_pooled/emb.GFPpooled.ElbowPlot.png")
```

The elbow plot is helpful when determining how many PCs we need to capture the majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC. Where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be a bit subjective about where the elbow is located.


# Cell clustering

Choose the number of PCs to use for clustering 
```{r}
emb.GFPpooled <- FindNeighbors(emb.GFPpooled, dims = 1:10)


## Find clusters using Clustree
# generate a vector of different resolutions to see which one performs best 
emb.GFPpooled.clust <- FindClusters(
  object = emb.GFPpooled,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:10,
  save.SNN = TRUE
)

## Now use Clustree to build a clustering tree based on the chosen resolutions specified above 
clustree(emb.GFPpooled.clust, prefix = "RNA_snn_res.")
ggsave("./Output/GFP_pooled/emb.GFPpooled.Clustree.png")


## Find clusters using original Surat package methods
# choose the appropriate resolution for the given dimensions using the Clustree data
emb.GFPpooled <- FindClusters(emb.GFPpooled, resolution = 1)
```


# Non-linear dimensional reduction (UMAP)

```{r}
emb.GFPpooled <- RunUMAP(emb.GFPpooled, dims = 1:10)
```

```{r}
# Note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
DimPlot(emb.GFPpooled, reduction = "umap", label = "TRUE", label.box = TRUE)
ggsave("./Output/GFP_pooled/emb.GFPpooled.UMAP.png")
```


# Find differentially expressed features (aka marker genes)

Find markers for every cluster compared to all remaining cells, report only the positive ones (otherwise = FALSE to also get negative)
```{r}
emb.GFPpooled.markers <- FindAllMarkers(emb.GFPpooled, only.pos = T, min.pct = 0.25, logfc.threshold = 1) # 0.25 is the default threshold 

emb.GFPpooled.markers %>% 
  group_by(cluster) %>% filter(p_val_adj < .01) %>%
  slice_max(n = 2, order_by = avg_log2FC)


write.csv(emb.GFPpooled.markers,"./Output/GFP_pooled/emb_GFPpooled_markers.csv", row.names = TRUE)
```


```{r}
# for justin

emb.GFPpooled.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=2, wt=avg_log2FC) -> top2

DoHeatmap(emb.GFPpooled, features = top2$gene,raster=F)
ggsave("./Output/GFP_pooled/emb.GFPpooled.HeatMap-top2.png")


FeaturePlot(emb.GFPpooled, features = c("elt-2","elt-7", 'ges-1'),raster=F)
ggsave("./Output/GFP_pooled/emb.GFPpooled.FeaturePlot-PostCtrls.png")

VlnPlot(emb.GFPpooled, features = c("elt-2","elt-7", 'ges-1'))
ggsave("./Output/GFP_pooled/emb.GFPpooled.VlnPlot-PostCtrls.png")


FeaturePlot(emb.GFPpooled, features = c("glh-1","chs-1", "myo-2", "myo-3", "hlh-2", "rab-3"), raster=F)
ggsave("./Output/GFP_pooled/emb.GFPpooled.FeaturePlot-NegCtrls.png")


VlnPlot(emb.GFPpooled, features = c("chs-1", "myo-2", "myo-3", "elt-2", "ges-1"))
ggsave("./Output/GFP_pooled/emb.GFPpooled.VlnPlot-NegCtrls.png")
```



Find all cluster specific markers (i.e., cluster 2)
```{r}
#emb.GFPpooled2.markers <- FindMarkers(emb.GFPpooled, ident.1 = 2, min.pct = 0.25)
#head(emb.GFPpooled2.markers, n = 5)
```

Find all markers distinguishing specific clusters (i.e., 5 from clusters 0 and 3) 
```{r}
#emb.GFPpooled5.markers <- FindMarkers(emb.GFPpooled, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
#head(emb.GFPpooled5.markers, n = 5)
```

Differential expression with ROC test
```{r}
#emb.GFPpooled0.markers <- FindMarkers(emb.GFPpooled, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)

#head(emb.GFPpooled0.markers)
```

# Perform gene ontology

```{r}
library(reticulate)

tea <- import("tissue_enrichment_analysis")
tissue_df <- tea$fetch_dictionary("tissue")
phenotype_df <- tea$fetch_dictionary("phenotype")
go_df <- tea$fetch_dictionary("go")
```

```{r}
emb.GFPpooled.markers <- emb.GFPpooled.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 

emb.GFPpooled.markers <- rename(emb.GFPpooled.markers, WBGeneID = wbps_gene_id)
```

```{r}
clusters <- unique(emb.GFPpooled.markers$cluster)

my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
    # %>% 
    #   filter(wbid %in% (input_df %>% 
    #                       filter(cluster %in% clusters))$WBGeneID)
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 50) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_grid(cluster~., scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(20,100,200))
}
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 1), tissue_df), "Tissue Ontology")

ggsave("./Output/GFP_pooled/emb.GFPpooled.GO.png")
```

#Pull out cluster specific CLECs 

```{r fig.height=4, fig.width=7}
emb.GFPpooled.markers %>% group_by(cluster) %>% filter(grepl("clec*",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10clecs

DoHeatmap(emb.GFPpooled, features = top10clecs$gene,raster=F)
ggsave("./Output/GFP_pooled/emb.GFPpooled.HeatMap-top10clecs.png")
```

# Find marker clecs in each cluster
```{r}
emb.GFPpooled.markers.clecs <- emb.GFPpooled.markers %>% 
  group_by(cluster) %>%
  filter(grepl("clec*",gene), p_val_adj < .01) %>%
  slice_max(n = 10, order_by = avg_log2FC)

write.csv(emb.GFPpooled.markers.clecs,"./Output/GFP_pooled/emb.GFPpooled.marker.clecs.csv", row.names = TRUE)
```

----- ignore for now -----

# Pull out cluster specific SPPs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.markers %>% group_by(cluster) %>% filter(grepl("^spp",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10spps

DoHeatmap(emb.GFPpooled, features = top10spps$gene,raster=F)
```

# Pull out cluster specific IRGs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.markers %>% group_by(cluster) %>% filter(grepl("^irg",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10irgs

DoHeatmap(emb.GFPpooled, features = top10irgs$gene,raster=F)
```

----- ignore for now -----

# Remove contamination clusters (based on tissue ontology data)
contamination clusters = 1, 10, 11, 12, 13

```{r}
emb.GFPpooled.specificClusters <- RunUMAP(subset(emb.GFPpooled, idents = c('1','10','11','12', '13'), invert = TRUE), dims = 1:10)

DimPlot(emb.GFPpooled.specificClusters, reduction = "umap", label = "TRUE", label.box = TRUE)
ggsave("./Output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.UMAP.png")
```

# now rerun PCA and re-lcuster 
```{r}
emb.GFPpooled.specificClusters <- RunPCA(emb.GFPpooled.specificClusters, features = VariableFeatures(object = emb.GFPpooled.specificClusters))

DimPlot(emb.GFPpooled.specificClusters, reduction = "pca")
ggsave("./Output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.UMAP.png")

ElbowPlot(emb.GFPpooled.specificClusters)
ggsave("./Output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.UMAP.png")
```

```{r}
# Choose the number of PCs to use for re-clustering 
emb.GFPpooled.specificClusters <- FindNeighbors(emb.GFPpooled.specificClusters, dims = 1:7)

# check new clusters with Clustree
emb.GFPpooled.specificClusters.recluster <- FindClusters(
  object = emb.GFPpooled.specificClusters,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:7,
  save.SNN = TRUE
)

clustree(emb.GFPpooled.specificClusters.recluster, prefix = "RNA_snn_res.")


emb.GFPpooled.specificClusters.recluster <- FindClusters(emb.GFPpooled.specificClusters, resolution = 1.2)

emb.GFPpooled.specificClusters.recluster <- RunUMAP(emb.GFPpooled.specificClusters.recluster, dims = 1:7)

DimPlot(emb.GFPpooled.specificClusters.recluster, reduction = "umap", label = "TRUE", label.box = TRUE)
```

# Find new marker genes
```{r}
emb.GFPpooled.specificClusters.recluster.markers <- FindAllMarkers(emb.GFPpooled.specificClusters.recluster, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.GFPpooled.specificClusters.recluster.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.GFPpooled.specificClusters.recluster.markers,"./Output/emb_GFPpooled_specificClusters_recluster_markers.csv", row.names = TRUE)
```

# Perform new gene ontology
```{r}
emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 

emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% rename(WBGeneID = wbps_gene_id)
```

```{r}
clusters <- unique(emb.GFPpooled.specificClusters.recluster.markers$cluster)
my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
    # %>% 
    #   filter(wbid %in% (input_df %>% 
    #                       filter(cluster %in% clusters))$WBGeneID)
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}
scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}
my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 50) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_grid(cluster~., scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(20,100,200))
}
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.specificClusters.recluster.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 0.5), tissue_df), "Tissue Ontology")
```

# Pull out new cluster marker genes 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=3, wt=avg_log2FC) -> top3

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top3$gene,raster=F)
```

# Pull out new cluster specific CLECs 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("clec*",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10clecs

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top10clecs$gene,raster=F)
```

# plot genes of interest

From John Murray dataset 
    - intestine_anterior: ZC204.12, cpr-1, ceh-37
    - intestine_middle_and_posterior: irg-7, pal-1, cpr-1, ceh-37
    - intestine_far_posterior: irg-7, faah-1, pbo-4, psa-3

```{r}
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c("elt-2","elt-7", 'ges-1'),raster=F)

VlnPlot(emb.GFPpooled.specificClusters.recluster, features = c("elt-2","elt-7", 'ges-1'))

# top marker gene for each cluster
FeaturePlot(emb.GFPpooled.specificClusters.recluster, pt.size = 0.1,
            features = (emb.GFPpooled.specificClusters.recluster.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 1, order_by = avg_log2FC))$gene
)

# genes from murray data
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('ZC204.12', 'cpr-1', 'ceh-37'), raster=F, , ncol = 3)

FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), raster=F, , ncol = 4)
VlnPlot(emb.GFPpooled.specificClusters.recluster, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), ncol = 4)

FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('faah-1', 'pbo-4', 'psa-3'), raster=F, ncol = 3)
VlnPlot(emb.GFPpooled.specificClusters.recluster, features = c('faah-1', 'pbo-4', 'psa-3'), ncol = 3)
```

