---
title: "embryo_scRNAseq"
author: "Jessica Hill"
date: "2/18/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---

```{r}
emb.unsort1.data <- Read10X_h5("./10x_cloud_analysis/unsort_1_count/raw_feature_bc_matrix.h5")

emb.unsort2.data <- Read10X_h5("./10x_cloud_analysis/unsort_2_count/raw_feature_bc_matrix.h5")

emb.GFP1.data <- Read10X_h5("./10x_cloud_analysis/GFP_1_count/raw_feature_bc_matrix.h5")

emb.GFP2.data <- Read10X_h5("./10x_cloud_analysis/GFP_2_count/raw_feature_bc_matrix.h5")
```

Get filternames from https://parasite.wormbase.org/biomart/martview
```{r}
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

genes.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "wbps_gene_id"),
      value = list("caelegprjna13758", rownames(emb.GFP2.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name')
      )

mitoList = genes.df[genes.df$chromosome_name == 'MtDNA', 'external_gene_id'] 

genes.df$chromosome_name = NULL 

c(nrow(genes.df), nrow(emb.GFP2.data))

# are there are genes missing?
nrow(emb.GFP2.data)-nrow(genes.df)
```

There are `r nrow(emb.data)-nrow(genes.df)` genes that are now dead, remove them from the input matrix.

```{r}
emb.unsort1.data.filt <- emb.unsort1.data[rownames(emb.unsort1.data) %in% genes.df$wbps_gene_id,]

emb.unsort2.data.filt <- emb.unsort2.data[rownames(emb.unsort2.data) %in% genes.df$wbps_gene_id,]

emb.GFP1.data.filt <- emb.GFP1.data[rownames(emb.GFP1.data) %in% genes.df$wbps_gene_id,]

emb.GFP2.data.filt <- emb.GFP2.data[rownames(emb.GFP2.data) %in% genes.df$wbps_gene_id,]

# The two datastructures do not have the same order of WBGeneIDs
identical(rownames(emb.unsort1.data.filt), genes.df$wbps_gene_id)
identical(rownames(emb.unsort2.data.filt), genes.df$wbps_gene_id)
identical(rownames(emb.GFP1.data.filt), genes.df$wbps_gene_id)
identical(rownames(emb.GFP2.data.filt), genes.df$wbps_gene_id)

# Use match to make sure they are in the same order
identical(rownames(emb.unsort1.data.filt),
          genes.df[match(rownames(emb.unsort1.data.filt), genes.df$wbps_gene_id),]$wbps_gene_id
          )

identical(rownames(emb.unsort2.data.filt),
          genes.df[match(rownames(emb.unsort2.data.filt), genes.df$wbps_gene_id),]$wbps_gene_id
          )

identical(rownames(emb.GFP1.data.filt),
          genes.df[match(rownames(emb.GFP1.data.filt), genes.df$wbps_gene_id),]$wbps_gene_id
          )

identical(rownames(emb.GFP2.data.filt),
          genes.df[match(rownames(emb.GFP2.data.filt), genes.df$wbps_gene_id),]$wbps_gene_id
          )

# now replace the WBGeneIDs with gene names
rownames(emb.unsort1.data.filt) <- genes.df[
  match(rownames(emb.unsort1.data.filt),
        genes.df$wbps_gene_id)
  ,]$external_gene_id

rownames(emb.unsort2.data.filt) <- genes.df[
  match(rownames(emb.unsort2.data.filt),
        genes.df$wbps_gene_id)
  ,]$external_gene_id

rownames(emb.GFP1.data.filt) <- genes.df[
  match(rownames(emb.GFP1.data.filt),
        genes.df$wbps_gene_id)
  ,]$external_gene_id

rownames(emb.GFP2.data.filt) <- genes.df[
  match(rownames(emb.GFP2.data.filt),
        genes.df$wbps_gene_id)
  ,]$external_gene_id

# are there NAs?
sum(!is.na(rownames(emb.unsort1.data.filt)))
sum(!is.na(rownames(emb.unsort2.data.filt)))
sum(!is.na(rownames(emb.GFP1.data.filt)))
sum(!is.na(rownames(emb.GFP2.data.filt)))
```

```{r}
emb.unsort1 <- CreateSeuratObject(counts = emb.unsort1.data.filt, project = "emb_unsort1", min.cells = 3, min.features = 200)

emb.unsort2 <- CreateSeuratObject(counts = emb.unsort2.data.filt, project = "emb_unsort2", min.cells = 3, min.features = 200)

emb.GFP1 <- CreateSeuratObject(counts = emb.GFP1.data.filt, project = "emb_GFP1", min.cells = 3, min.features = 200)

emb.GFP2 <- CreateSeuratObject(counts = emb.GFP2.data.filt, project = "emb_GFP2", min.cells = 3, min.features = 200)
```

```{r}
length(unique(genes.df$wbps_gene_id))
length(unique(rownames(emb.unsort1)))
rownames(emb.unsort1)[!(rownames(emb.unsort1) %in% genes.df$wbps_gene_id)]

length(unique(genes.df$wbps_gene_id))
length(unique(rownames(emb.unsort2)))
rownames(emb.unsort2)[!(rownames(emb.unsort2) %in% genes.df$wbps_gene_id)]

length(unique(genes.df$wbps_gene_id))
length(unique(rownames(emb.GFP1)))
rownames(emb.GFP1)[!(rownames(emb.GFP1) %in% genes.df$wbps_gene_id)]

length(unique(genes.df$wbps_gene_id))
length(unique(rownames(emb.GFP2)))
rownames(emb.GFP2)[!(rownames(emb.GFP2) %in% genes.df$wbps_gene_id)]
```

# Quality control metrics

Mitochondrial genome percentage 
```{r}
mitoIndices = which(rownames(emb.unsort1) %in% mitoList)
emb.unsort1[["percent.mt"]] <- PercentageFeatureSet(emb.unsort1, features = mitoIndices)

mitoIndices = which(rownames(emb.unsort2) %in% mitoList)
emb.unsort2[["percent.mt"]] <- PercentageFeatureSet(emb.unsort2, features = mitoIndices)

mitoIndices = which(rownames(emb.GFP1) %in% mitoList)
emb.GFP1[["percent.mt"]] <- PercentageFeatureSet(emb.GFP1, features = mitoIndices)

mitoIndices = which(rownames(emb.GFP2) %in% mitoList)
emb.GFP2[["percent.mt"]] <- PercentageFeatureSet(emb.GFP2, features = mitoIndices)
```


- `nFeature_RNA` is the number of genes detected in each cell. 
- `nCount_RNA` is the total number of molecules detected within a cell (AKA total UMIs per cell)
- Low `nFeature_RNA` indicates that the cell may be dead or dying or an empty droplet
- High `nCount_RNA` and/or `nFeature_RNA` indicates that the "cell" may in fact be a doublet (or multiplet)


Visualize QC metrics as a violin plot
```{r}
VlnPlot(emb.unsort1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(emb.unsort2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(emb.GFP1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(emb.GFP2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
```{r}
plot1 <- FeatureScatter(emb.unsort1, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.unsort1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(emb.unsort2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.unsort2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(emb.GFP1, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.GFP1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

plot1 <- FeatureScatter(emb.GFP2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.GFP2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

# Filter based on features

cells being filtered due to mito percent: 
```{r}
sum(emb.unsort1$percent.mt > 50)/ length(emb.unsort1$percent.mt)
emb.unsort1 <- subset(emb.unsort1, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)

sum(emb.unsort2$percent.mt > 50)/ length(emb.unsort2$percent.mt)
emb.unsort2 <- subset(emb.unsort2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)

sum(emb.GFP1$percent.mt > 50)/ length(emb.GFP1$percent.mt)
emb.GFP1 <- subset(emb.GFP1, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)

sum(emb.GFP2$percent.mt > 50)/ length(emb.GFP2$percent.mt)
emb.GFP2 <- subset(emb.GFP2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```

# Visualize after filtering
```{r}
VlnPlot(emb.unsort1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
FeatureScatter(emb.unsort1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

VlnPlot(emb.unsort2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
FeatureScatter(emb.unsort2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

VlnPlot(emb.GFP1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
FeatureScatter(emb.GFP1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

VlnPlot(emb.GFP2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
FeatureScatter(emb.GFP2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
```

# Normalize the data

Normalize the count data present in the assay. 

LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. This is then natural-log transformed using log1p.

Scale.factor: Sets the scale factor for cell-level normalization

```{r}
emb.unsort1 <- NormalizeData(emb.unsort1, normalization.method = "LogNormalize", scale.factor = 10000)

emb.unsort2 <- NormalizeData(emb.unsort2, normalization.method = "LogNormalize", scale.factor = 10000)

emb.GFP1 <- NormalizeData(emb.GFP1, normalization.method = "LogNormalize", scale.factor = 10000)

emb.GFP2 <- NormalizeData(emb.GFP2, normalization.method = "LogNormalize", scale.factor = 10000)
```

# Feature selection

Identify highly variable features to focus on in downstream analysis
```{r}
emb.unsort1 <- FindVariableFeatures(emb.unsort1, selection.method = "vst", nfeatures = 2000)
emb.unsort2 <- FindVariableFeatures(emb.unsort2, selection.method = "vst", nfeatures = 2000)
emb.GFP1 <- FindVariableFeatures(emb.GFP1, selection.method = "vst", nfeatures = 2000)
emb.GFP2 <- FindVariableFeatures(emb.GFP2, selection.method = "vst", nfeatures = 2000)


# Identify the 10 most highly variable genes
emb.unsort1.top10 <- head(VariableFeatures(emb.unsort1), 10)
emb.unsort2.top10 <- head(VariableFeatures(emb.unsort2), 10)
emb.GFP1.top10 <- head(VariableFeatures(emb.GFP1), 10)
emb.GFP2.top10 <- head(VariableFeatures(emb.GFP2), 10)
```

```{r}
# plot variable features with and without labels
plot1 <- VariableFeaturePlot(emb.unsort1)
LabelPoints(plot = plot1, points = emb.unsort1.top10, repel = TRUE)
ggsave("./Output/unsort1/emb.unsort1.variablefeatures.png")
```

```{r}
plot1 <- VariableFeaturePlot(emb.unsort2)
LabelPoints(plot = plot1, points = emb.unsort2.top10, repel = TRUE)
ggsave("./Output/unsort2/emb.unsort2.variablefeatures.png")
```

```{r}
plot1 <- VariableFeaturePlot(emb.GFP1)
LabelPoints(plot = plot1, points = emb.GFP1.top10, repel = TRUE)
ggsave("./Output/GFP1/emb.GFP1.variablefeatures.png")
```

```{r}
plot1 <- VariableFeaturePlot(emb.GFP2)
LabelPoints(plot = plot1, points = emb.GFP2.top10, repel = TRUE)
ggsave("./Output/GFP2/emb.GFP2.variablefeatures.png")
```




# Normalization

Scale the data so that each gene has a mean expression of 0 and variance of 1 across all cells
```{r}
unsort1.all.genes <- rownames(emb.unsort1)
emb.unsort1 <- ScaleData(emb.unsort1, features = unsort1.all.genes)

unsort2.all.genes <- rownames(emb.unsort2)
emb.unsort2 <- ScaleData(emb.unsort2, features = unsort2.all.genes)

GFP1.all.genes <- rownames(emb.GFP1)
emb.GFP1 <- ScaleData(emb.GFP1, features = GFP1.all.genes)

GFP2.all.genes <- rownames(emb.GFP2)
emb.GFP2 <- ScaleData(emb.GFP2, features = GFP2.all.genes)
```

# Linear dimensionality reduction 

PCA linear dimensionality reduction
```{r}
emb.unsort1 <- RunPCA(emb.unsort1, features = VariableFeatures(object = emb.unsort1))

emb.unsort2 <- RunPCA(emb.unsort2, features = VariableFeatures(object = emb.unsort2))

emb.GFP1 <- RunPCA(emb.GFP1, features = VariableFeatures(object = emb.GFP1))

emb.GFP2 <- RunPCA(emb.GFP2, features = VariableFeatures(object = emb.GFP2))
```


# Determine dataset dimensionality

An alternative, more approximate technique is the elbow plot, which ranges principle components based on the percentage of variance explained by each PC.

The elbow plot is helpful when determining how many PCs we need to capture the majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC. Where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be a bit subjective about where the elbow is located.

```{r}
ElbowPlot(emb.unsort1) # can try 3 or 5
ggsave("./Output/unsort1/emb.unsort1.elbowplot.png")
```

```{r}
ElbowPlot(emb.unsort2) # can try 5
ggsave("./Output/unsort2/emb.unsort2.elbowplot.png")
```

```{r}
ElbowPlot(emb.GFP1) # can try 4 or 5
ggsave("./Output/GFP1/emb.GFP1.elbowplot.png")
```

```{r}
ElbowPlot(emb.GFP2) # can try 3 or 5
ggsave("./Output/GFP2/emb.GFP2.elbowplot.png")
```




# Cell clustering

Choose the number of PCs to use for clustering 
```{r}
emb.unsort1 <- FindNeighbors(emb.unsort1, dims = 1:5)
emb.unsort2 <- FindNeighbors(emb.unsort2, dims = 1:5)
emb.GFP1 <- FindNeighbors(emb.GFP1, dims = 1:5)
emb.GFP2 <- FindNeighbors(emb.GFP2, dims = 1:5)


# adjust for each sample

emb_clust.GFP2 <- FindClusters(
  object = emb.GFP2,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:5,
  save.SNN = TRUE
)


clustree(emb_clust.unsort1, prefix = "RNA_snn_res.")
clustree(emb_clust.unsort2, prefix = "RNA_snn_res.")
clustree(emb_clust.GFP1, prefix = "RNA_snn_res.")
clustree(emb_clust.GFP2, prefix = "RNA_snn_res.")


# Now find clusters using original Surat package methods, and choose the appropriate resolution for the given dimensions using the Clustree data

emb.unsort1 <- FindClusters(emb.unsort1, resolution = 1.2)
emb.unsort2 <- FindClusters(emb.unsort2, resolution = 1)
emb.GFP1 <- FindClusters(emb.GFP1, resolution = 1.2)
emb.GFP2 <- FindClusters(emb.GFP2, resolution = 1.2)
```




# Non-linear dimensional reduction (UMAP/tSNE)

```{r}
emb.unsort1 <- RunUMAP(emb.unsort1, dims = 1:5)
emb.unsort2 <- RunUMAP(emb.unsort2, dims = 1:5)
emb.GFP1 <- RunUMAP(emb.GFP1, dims = 1:5)
emb.GFP2 <- RunUMAP(emb.GFP2, dims = 1:5)
```

```{r}
# Note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters

DimPlot(emb.unsort1, reduction = "umap", label = "TRUE", label.box = TRUE)
ggsave("./Output/unsort1/emb.unsort1.umap.png")
```

```{r}
DimPlot(emb.unsort2, reduction = "umap", label = "TRUE", label.box = TRUE)
ggsave("./Output/unsort2/emb.unsort2.umap.png")
```

```{r}
DimPlot(emb.GFP1, reduction = "umap", label = "TRUE", label.box = TRUE)
ggsave("./Output/GFP1/emb.GFP1.umap.png")
```

```{r}
DimPlot(emb.GFP2, reduction = "umap", label = "TRUE", label.box = TRUE)
ggsave("./Output/GFP2/emb.GFP2.umap.png")
```



# Find differentially expressed features (aka marker genes)

Find markers for every cluster compared to all remaining cells, report only the positive ones (otherwise = FALSE to also get negative)

```{r}
emb.unsort1.markers <- FindAllMarkers(emb.unsort1, only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)

emb.unsort1.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.unsort1.markers,"/Users/jessicahill/Documents/GitHub/Celegans_Embryo_scRNAseq_ImmuneFunction/Output/unsort1/emb_unsort1_markers.csv", row.names = TRUE)
```

```{r}
emb.unsort2.markers <- FindAllMarkers(emb.unsort2, only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)

emb.unsort2.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.unsort2.markers,"/Users/jessicahill/Documents/GitHub/Celegans_Embryo_scRNAseq_ImmuneFunction/Output/unsort2/emb_unsort2_markers.csv", row.names = TRUE)
```

```{r}
emb.GFP1.markers <- FindAllMarkers(emb.GFP1, only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)

emb.GFP1.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.GFP1.markers,"/Users/jessicahill/Documents/GitHub/Celegans_Embryo_scRNAseq_ImmuneFunction/Output/GFP1/emb_GFP1_markers.csv", row.names = TRUE)
```

```{r}
emb.GFP2.markers <- FindAllMarkers(emb.GFP2, only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)

emb.GFP2.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.GFP2.markers,"/Users/jessicahill/Documents/GitHub/Celegans_Embryo_scRNAseq_ImmuneFunction/Output/GFP2/emb_GFP2_markers.csv", row.names = TRUE)
```